<!DOCTYPE html>

<html>
<head>
  <title>ClientController.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="ClientController.html">
                  ClientController.js
                </a>
              
                
                <a class="source" href="ClientRequest.html">
                  ClientRequest.js
                </a>
              
                
                <a class="source" href="ExpressServerRequest.html">
                  ExpressServerRequest.js
                </a>
              
                
                <a class="source" href="ReactServerAgent.html">
                  ReactServerAgent.js
                </a>
              
                
                <a class="source" href="Cache.html">
                  Cache.js
                </a>
              
                
                <a class="source" href="Plugins.html">
                  Plugins.js
                </a>
              
                
                <a class="source" href="Request.html">
                  Request.js
                </a>
              
                
                <a class="source" href="handlePage.html">
                  handlePage.js
                </a>
              
                
                <a class="source" href="loggingClient.html">
                  loggingClient.js
                </a>
              
                
                <a class="source" href="ClientRequestSpec.html">
                  ClientRequestSpec.js
                </a>
              
                
                <a class="source" href="NormalValuesPage.html">
                  NormalValuesPage.js
                </a>
              
                
                <a class="source" href="NullValuePromisesPage.html">
                  NullValuePromisesPage.js
                </a>
              
                
                <a class="source" href="NullValuesPage.html">
                  NullValuesPage.js
                </a>
              
                
                <a class="source" href="reactMiddlewareSpec.html">
                  reactMiddlewareSpec.js
                </a>
              
                
                <a class="source" href="client.html">
                  client.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="History.html">
                  History.js
                </a>
              
                
                <a class="source" href="RootContainer.html">
                  RootContainer.js
                </a>
              
                
                <a class="source" href="RootElement.html">
                  RootElement.js
                </a>
              
                
                <a class="source" href="TheFold.html">
                  TheFold.js
                </a>
              
                
                <a class="source" href="config.html">
                  config.js
                </a>
              
                
                <a class="source" href="constants.html">
                  constants.js
                </a>
              
                
                <a class="source" href="Navigator.html">
                  Navigator.js
                </a>
              
                
                <a class="source" href="RequestContext.html">
                  RequestContext.js
                </a>
              
                
                <a class="source" href="logging.html">
                  logging.js
                </a>
              
                
                <a class="source" href="client.html">
                  client.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="response.html">
                  response.js
                </a>
              
                
                <a class="source" href="server.html">
                  server.js
                </a>
              
                
                <a class="source" href="stats.html">
                  stats.js
                </a>
              
                
                <a class="source" href="renderMiddleware.html">
                  renderMiddleware.js
                </a>
              
                
                <a class="source" href="server.html">
                  server.js
                </a>
              
                
                <a class="source" href="ClientCssHelper.html">
                  ClientCssHelper.js
                </a>
              
                
                <a class="source" href="DebugUtil.html">
                  DebugUtil.js
                </a>
              
                
                <a class="source" href="PageUtil.html">
                  PageUtil.js
                </a>
              
                
                <a class="source" href="RequestLocalStorage.html">
                  RequestLocalStorage.js
                </a>
              
                
                <a class="source" href="StringEscapeUtil.html">
                  StringEscapeUtil.js
                </a>
              
                
                <a class="source" href="bundleNameUtil.html">
                  bundleNameUtil.js
                </a>
              
                
                <a class="source" href="navigateTo.html">
                  navigateTo.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>ClientController.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>),
	ReactDOM = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom'</span>),
	logging = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logging'</span>),
	RequestContext = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./context/RequestContext'</span>),
	RequestLocalStorage = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/RequestLocalStorage'</span>),
	DebugUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/DebugUtil'</span>).default,
	Q = <span class="hljs-built_in">require</span>(<span class="hljs-string">'q'</span>),
	cssHelper = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/ClientCssHelper'</span>),
	EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"events"</span>).EventEmitter,
	ClientRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./ClientRequest"</span>),
	History = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./components/History'</span>),
	PageUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./util/PageUtil"</span>),
	ReactServerAgent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ReactServerAgent'</span>),
	{getRootElementAttributes} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./components/RootElement'</span>),
	{PAGE_LINK_NODE_ID, PAGE_CONTAINER_NODE_ID} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./constants'</span>);

<span class="hljs-keyword">var</span> _ = {
	<span class="hljs-attr">forEach</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash/forEach'</span>),
	<span class="hljs-attr">assign</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash/assign'</span>),
};

<span class="hljs-keyword">var</span> RLS = RequestLocalStorage.getNamespace();

<span class="hljs-keyword">var</span> logger = logging.getLogger(__LOGGER__);</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>for dev tools</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">window</span>.React = React;

<span class="hljs-keyword">var</span> REACT_SERVER_DATA_ATTRIBUTE = <span class="hljs-string">"data-react-server-root-id"</span>;

<span class="hljs-comment">/**
 * Set up a Q error handler to make sure that errors that bubble
 * up are logged via our logger. Note: This will affect all unhandled
 * Q promise rejections, not just the ones in this file.
 */</span>
Q.onerror = <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
	logger.error(<span class="hljs-string">"Unhandled exception in Q promise"</span>, err);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHistoryStateFrame</span>(<span class="hljs-params">request</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Mark the frame as ours.
Stash the request opts that were used to navigate to this frame.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> { <span class="hljs-attr">reactServerFrame</span>: request?request.getOpts():{} }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHistoryPathname</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> location.pathname + location.search + location.hash;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span> </span>{

	<span class="hljs-keyword">constructor</span> ({routes}) {
		<span class="hljs-keyword">super</span>();

		<span class="hljs-built_in">window</span>.__reactServerTimingStart = <span class="hljs-built_in">window</span>.performance ? <span class="hljs-built_in">window</span>.performance.timing.navigationStart : <span class="hljs-literal">undefined</span>;

		<span class="hljs-keyword">var</span> dehydratedState = <span class="hljs-built_in">window</span>.__reactServerState;

		checkNotEmpty(dehydratedState, <span class="hljs-string">'InitialContext'</span>);
		checkNotEmpty(dehydratedState, <span class="hljs-string">'Config'</span>);

		RequestLocalStorage.startRequest();

		<span class="hljs-keyword">this</span>.config = buildConfig(dehydratedState.Config);

		<span class="hljs-keyword">if</span> (routes.onClientConfigLoaded) {
			routes.onClientConfigLoaded.call(<span class="hljs-keyword">this</span>);
		}

		<span class="hljs-keyword">this</span>.context = buildContext(routes);
		<span class="hljs-keyword">this</span>.context.setDeviceType(dehydratedState.InitialContext.deviceType);
		ReactServerAgent.cache().rehydrate(dehydratedState.InitialContext[<span class="hljs-string">'ReactServerAgent.cache'</span>]);
		<span class="hljs-keyword">this</span>.mountNode = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'content'</span>);

		<span class="hljs-keyword">this</span>._setupNavigateListener();
		<span class="hljs-keyword">this</span>._setupArrivalHandlers();

		<span class="hljs-keyword">this</span>._previouslyRendered = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">this</span>._rootNodeDfds = [];
		<span class="hljs-keyword">this</span>._failDfd = Q.defer();</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Log this after loglevel is set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		logTimingData(<span class="hljs-string">'wakeFromStart'</span>, <span class="hljs-built_in">window</span>.__reactServerTimingStart);

		performanceMark(<span class="hljs-string">'wake'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>this is a proxy for when above the fold content gets painted (displayed) on the browser</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		logTimingData(<span class="hljs-string">'displayAboveTheFold.fromStart'</span>, <span class="hljs-built_in">window</span>.__reactServerTimingStart, <span class="hljs-built_in">window</span>.__displayAboveTheFold);
	}

	terminate() {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>We may not have set up any history stuff…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._history) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">this</span>._history.off(<span class="hljs-keyword">this</span>._historyListener);
		<span class="hljs-keyword">this</span>._historyListener = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">this</span>._history = <span class="hljs-literal">null</span>;
	}

	_startRequest({request, type}) {

		<span class="hljs-keyword">const</span> t0 = type === History.events.PAGELOAD
			?<span class="hljs-built_in">window</span>.__reactServerTimingStart <span class="hljs-comment">// Try to use navigation timing.</span>
			:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;                       <span class="hljs-comment">// There's no naviagation.  We're it.</span>

		<span class="hljs-keyword">const</span> url = request.getUrl();
		<span class="hljs-keyword">const</span> isPush = type === History.events.PUSHSTATE;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>This is the navigator we’re going to listen to regarding when navigation
is complete for timing purposes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">let</span> navigationTimingAuthority = <span class="hljs-keyword">this</span>.context.navigator;

		<span class="hljs-keyword">this</span>._reuseDom = request.getReuseDom();

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._previouslyRendered) {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>This is a secondary request (client transition)
within a session, so we’ll get a fresh
RequestLocalStorage container.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			RequestLocalStorage.startRequest();</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If we’re not going to reuse the DOM, let’s
clean up right away to blank the screen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._reuseDom) {
				<span class="hljs-keyword">this</span>._cleanupPreviousRender();
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>we need to re-register the request context
as a RequestLocal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.context.registerRequestLocal();
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>If this is a History.events.PUSHSTATE navigation,
and we have control of the navigation bar we should
change the URL in the location bar before rendering.</p>
<p>Note that for browsers that do not have pushState,
this will result in a window.location change and
full browser load.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._history) {

			<span class="hljs-keyword">if</span> (isPush) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Sorry folks.  If we need to do a client
transition, then we’re going to clobber
your state.  You must be able to render
from URL, anyway, so if you’re set up right
it won’t affect user experience.  It means,
though, that there exists a navigation path
to an extraneous full-page rebuild.
Such is life.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Don’t replace state unless we’ve
got a real history API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">this</span>._history.canClientNavigate() &amp;&amp;
					!(history.state||{}).reactServerFrame
				){
					<span class="hljs-keyword">this</span>._history.replaceState(
						getHistoryStateFrame(),
						<span class="hljs-literal">null</span>,
						getHistoryPathname()
					);
				}

				<span class="hljs-keyword">this</span>._setHistoryRequestOpts({</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>If we’re reusing the DOM on the way
forward, then we can also reuse on
the way back.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					reuseDom: request.getReuseDom(),
				});

				<span class="hljs-keyword">this</span>._history.pushState(
					getHistoryStateFrame(request),
					<span class="hljs-literal">null</span>,
					url
				);
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === History.events.PAGELOAD) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>This <em>seems</em> redundant with the
<code>replaceState</code> above, but keep in mind that
an initial <code>pushState</code> might not be a
client transition.  It could be a
non-<code>react-server</code> use of the history API.</p>
<p>This also <em>replaces</em> state with the request
URL, which handles client-side redirects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._history.replaceState(
					getHistoryStateFrame(request),
					<span class="hljs-literal">null</span>,
					url
				)

				<span class="hljs-keyword">this</span>._setHistoryRequestOpts({</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>If we wind up back here without
first client-transitioning away
then presumably we’re still on the
same page that just had some
history maniptulation outside of
<code>react-server</code>.  In that case we’re
ourselves and we should be able to
re-use the DOM.  Maybe
presumptuous, but a nicer
experience than clobbering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					reuseDom: <span class="hljs-literal">true</span>,
				});
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>logging how long the request took in a variety of ways:</p>
<ul>
<li>Request type (pageload, pushstate, popstate)</li>
<li>Request options (reuseDom, bundleData, etc)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>		navigationTimingAuthority.once(<span class="hljs-string">'loadComplete'</span>, () =&gt; {
			<span class="hljs-keyword">const</span> bas = <span class="hljs-string">`handleRequest`</span>;
			<span class="hljs-keyword">const</span> typ = <span class="hljs-string">`type.<span class="hljs-subst">${type||<span class="hljs-string">'PAGELOAD'</span>}</span>`</span>;
			logTimingData(<span class="hljs-string">`<span class="hljs-subst">${bas}</span>.all`</span>, t0);
			logTimingData(<span class="hljs-string">`<span class="hljs-subst">${bas}</span>.<span class="hljs-subst">${typ}</span>.all`</span>, t0);
			_.forEach(request.getOpts(), (val, key) =&gt; {
				<span class="hljs-keyword">if</span> (val) {
					<span class="hljs-keyword">const</span> opt = <span class="hljs-string">`opt.<span class="hljs-subst">${key}</span>`</span>;
					logTimingData(<span class="hljs-string">`<span class="hljs-subst">${bas}</span>.<span class="hljs-subst">${opt}</span>`</span>, t0);
					logTimingData(<span class="hljs-string">`<span class="hljs-subst">${bas}</span>.<span class="hljs-subst">${typ}</span>.<span class="hljs-subst">${opt}</span>`</span>, t0);
				}
			});
		});

		<span class="hljs-keyword">this</span>._lastState = history.state;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Update the request options for the <em>current</em> history navigation
state frame prior to pushing a new frame.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	_setHistoryRequestOpts(opts) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If we don’t have a real history API then we don’t want to
mess with state since it results in full navigation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._history.canClientNavigate()) <span class="hljs-keyword">return</span>;

		<span class="hljs-keyword">const</span> state = _.assign({}, history.state);
		state.reactServerFrame = _.assign(state.reactServerFrame||{}, opts);
		<span class="hljs-keyword">this</span>._history.replaceState(state, <span class="hljs-literal">null</span>, getHistoryPathname());
	}

	_setupNavigateListener () {
		<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.context;

		context.onNavigateStart(<span class="hljs-keyword">this</span>._startRequest.bind(<span class="hljs-keyword">this</span>));

		<span class="hljs-comment">/**
		 * type is one of
		 *    History.events.PUSHSTATE: user clicked something to go forward but browser didn't do a
		 * full page load
		 *    History.events.POPSTATE: user clicked back button but browser didn't do a full page load
		 *    History.events.PAGELOAD: full browser page load, not using History API.
		 */</span>
		context.onNavigate( <span class="hljs-function">(<span class="hljs-params">err, page</span>) =&gt;</span> {
			logger.debug(<span class="hljs-string">'Executing navigate action'</span>);

			<span class="hljs-keyword">this</span>._handleDebugParams(page);

			<span class="hljs-keyword">if</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>redirects are sent as errors, so let’s handle it if that’s the case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (err.status &amp;&amp; (err.status === <span class="hljs-number">301</span> || err.status === <span class="hljs-number">302</span>)) {
					<span class="hljs-keyword">if</span> (!err.redirectUrl) {
						<span class="hljs-built_in">console</span>.error(<span class="hljs-string">"A redirect status was sent without a corresponding redirect redirectUrl."</span>, err);
					} <span class="hljs-keyword">else</span> {
						setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>we’re about to load the <em>next</em> page, so we should mark the
redirect navigation finished</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>							context.navigator.finishRoute();
							context.navigate(<span class="hljs-keyword">new</span> ClientRequest(err.redirectUrl));
						}, <span class="hljs-number">0</span>);
					}
				} <span class="hljs-keyword">else</span> {
					logger.error(<span class="hljs-string">"onNavigate error"</span>, err);
				}
				<span class="hljs-keyword">return</span>;
			}

			<span class="hljs-keyword">var</span> routeName = context.navigator.getCurrentRoute().name;

			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._previouslyRendered) {
				cssHelper.registerPageLoad(routeName);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>render the document title.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._renderTitle(page);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>render the base tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._renderBase(page);

				<span class="hljs-keyword">this</span>._renderMetaTags(page);

				<span class="hljs-keyword">this</span>._renderLinkTags(page);
			}

			cssHelper.ensureCss(routeName, page)
				.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
					page.getBodyClasses().then(<span class="hljs-function">(<span class="hljs-params">classes</span>) =&gt;</span> {
						classes.push(<span class="hljs-string">`route-<span class="hljs-subst">${routeName}</span>`</span>);
						<span class="hljs-built_in">document</span>.body.className = classes.join(<span class="hljs-string">' '</span>);
					}))
				.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._render(page)).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
					logger.error(<span class="hljs-string">"Error during client transition render"</span>, err);
				}).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>We’re responsible for letting the navigator
know when we’re more or less done stomping
around in the current request context
setting things up.</p>
<p>We can’t <em>guarantee</em> that pages/middleware
haven’t set timers to mess with things in
the future, so we need to wait a bit before
letting the navigator yank our context if
an immediate subsequent navigation is
scheduled.</p>
<p>I don’t like this magic delay here, but it
gives us a better shot at falling after
things like lazy load images do their
post-render wire-up.</p>
<p>Anything that the current page does in the
request context <em>after</em> this timeout has
elapsed and we’ve started a subsequent
navigation is pure corruption. :p</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> context.navigator.finishRoute(), <span class="hljs-number">200</span>);
				}).done();

		});

	}

	_handleDebugParams(page) {
		<span class="hljs-keyword">if</span> (!page) <span class="hljs-keyword">return</span>;

		DebugUtil.setRequest(page.getRequest());

		<span class="hljs-keyword">const</span> params = DebugUtil.getAllDebugValues();</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Allow adjustment of log levels.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_.forEach({
			<span class="hljs-attr">_react_server_log_level</span>       : <span class="hljs-string">'main'</span>,
			<span class="hljs-attr">_react_server_log_level_main</span>  : <span class="hljs-string">'main'</span>,
			<span class="hljs-attr">_react_server_log_level_time</span>  : <span class="hljs-string">'time'</span>,
			<span class="hljs-attr">_react_server_log_level_gauge</span> : <span class="hljs-string">'gauge'</span>,
		}, (type, param) =&gt; {
			<span class="hljs-keyword">if</span> (params[param]) {
				logging.setLevel(type,  params[param]);
			}
		});
	}

	_renderTitle(page) {
		page.getTitle().then(<span class="hljs-function"><span class="hljs-params">newTitle</span> =&gt;</span> {
			<span class="hljs-keyword">if</span> (newTitle &amp;&amp; newTitle !== <span class="hljs-built_in">document</span>.title) {
				<span class="hljs-built_in">document</span>.title = newTitle;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>This is the earliest we have everything we need for
an analytics pageview event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>.emit(<span class="hljs-string">"pageview"</span>, {
				<span class="hljs-attr">page</span>  : getHistoryPathname(),
				<span class="hljs-attr">title</span> : newTitle,
			});
		})
			.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { logger.error(<span class="hljs-string">"Error while setting the document title"</span>, err) })
			.done();
	}

	_renderBase(page) {
		page.getBase().then(<span class="hljs-function"><span class="hljs-params">base</span> =&gt;</span> {
			<span class="hljs-keyword">var</span> currentBaseTag = <span class="hljs-built_in">document</span>.head.querySelector(<span class="hljs-string">"head base"</span>);
			<span class="hljs-keyword">if</span> (base === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>get rid of the current base tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (currentBaseTag) currentBaseTag.parentNode.removeChild(currentBaseTag);
			} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>we need a base tag. add one if it’s not there yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (!currentBaseTag) {
					currentBaseTag = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"base"</span>);
					<span class="hljs-built_in">document</span>.head.appendChild(currentBaseTag);
				}
				<span class="hljs-keyword">if</span> (base.href) currentBaseTag.href = base.href;
				<span class="hljs-keyword">if</span> (base.target) currentBaseTag.target = base.target;
			}

		}).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
			logger.error(<span class="hljs-string">"Error rendering &lt;base&gt;"</span>, err);
		}).done();
	}

	_renderMetaTags(page) {</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>first, remove all the current meta tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> currentMetaTags = <span class="hljs-built_in">document</span>.head.querySelectorAll(<span class="hljs-string">"meta"</span>);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; currentMetaTags.length; i++) {
			currentMetaTags[i].parentNode.removeChild(currentMetaTags[i]);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>now add all the meta tags for the new page.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		page.getMetaTags().forEach(<span class="hljs-function">(<span class="hljs-params">metaTagPromise</span>) =&gt;</span> {
			metaTagPromise.then(<span class="hljs-function">(<span class="hljs-params">metaTag</span>) =&gt;</span> {
				<span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.head;
				<span class="hljs-keyword">if</span> (metaTag.noscript) {
					<span class="hljs-keyword">var</span> noscript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"noscript"</span>);
					parent.appendChild(noscript);
					parent = noscript;
				}

				<span class="hljs-keyword">var</span> meta = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"meta"</span>);
				[<span class="hljs-string">"name"</span>, <span class="hljs-string">"httpEquiv"</span>, <span class="hljs-string">"charset"</span>, <span class="hljs-string">"content"</span>].forEach(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
					<span class="hljs-keyword">if</span> (metaTag[name]) meta[name] = metaTag[name];
				});

				parent.appendChild(meta);
			})
				.catch( <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { logger.error(<span class="hljs-string">"Error rendering meta tags"</span>, err); })
				.done();
		});
	}

	_renderLinkTags(page) {</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>First, remove all the current link tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		;[].slice.call(<span class="hljs-built_in">document</span>.head.querySelectorAll(<span class="hljs-string">`link[<span class="hljs-subst">${PAGE_LINK_NODE_ID}</span>]`</span>))
			.forEach(<span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> tag.parentNode.removeChild(tag));</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Then add all the link tags for the new page.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		page.getLinkTags()
			.forEach(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> promise.then(PageUtil.makeArray).then(<span class="hljs-function"><span class="hljs-params">tags</span> =&gt;</span> tags.forEach(<span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> {
				<span class="hljs-built_in">document</span>.head.appendChild(
					[<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'link'</span>), PAGE_LINK_NODE_ID]
						.concat(<span class="hljs-built_in">Object</span>.keys(tag))
						.reduce(<span class="hljs-function">(<span class="hljs-params">link, attr</span>) =&gt;</span> (link.setAttribute(attr, tag[attr] || <span class="hljs-string">''</span>), link))
				);
			})).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> logger.error(<span class="hljs-string">"Error rendering link tags"</span>, err)).done());
	}

	_render (page) {
		<span class="hljs-keyword">var</span> tStart = <span class="hljs-built_in">window</span>.__reactServerTimingStart;
		<span class="hljs-keyword">var</span> t0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
		<span class="hljs-keyword">var</span> retval = Q.defer();

		logger.debug(<span class="hljs-string">'React Rendering'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>We keep track of the <em>total</em> time we spent rendering during
each request so we can keep track of that overhead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> totalRenderTime = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>These resolve with React elements when their data
dependencies are fulfilled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> elementPromises = PageUtil.standardizeElements(page.getElements());
		<span class="hljs-keyword">var</span> timeoutDfd = [];
		<span class="hljs-keyword">var</span> elementPromisesOr = elementPromises.map(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {
			<span class="hljs-keyword">var</span> orPromise = Q.defer();
			timeoutDfd[index] = Q.defer();

			promise.then(orPromise.resolve);
			promise.catch(orPromise.reject);
			timeoutDfd[index].promise.catch(orPromise.reject);

			<span class="hljs-keyword">return</span> orPromise.promise;
		});</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>These resolve with DOM mount points for the elements.</p>
<p>Our behavior is different here for the <em>first</em> render vs
during a client transition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> rootNodePromises;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._previouslyRendered){</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>On a client transition we’ve just blown away all of
our mount points from the previous page, and we’ll
create a fresh set.  We’ll defer creating them
until we’ve actually got our elements, since some
items in the elements array may be container
control.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			rootNodePromises = elementPromises.map(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Q())
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>On our <em>first</em> render we want to mount to the DOM
nodes produced during the <em>server-side</em> render.</p>
<p>We’re awake and doing our thing while these
server-rendered elements are streaming down, so we
need to wait to render a given element until its
mount point arrives.</p>
<p>The server will tell us when each mount point is
ready by calling <code>nodeArrival</code>, which triggers
resolution of the corresponding <code>rootNodePromise</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			elementPromises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {
				<span class="hljs-keyword">this</span>._ensureRootNodeDfd(index);
			});
			rootNodePromises = <span class="hljs-keyword">this</span>._rootNodeDfds.map(<span class="hljs-function"><span class="hljs-params">dfd</span> =&gt;</span> dfd.promise);
		}

		<span class="hljs-keyword">var</span> mountNode = <span class="hljs-keyword">this</span>.mountNode;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>These are only used if we’re going to try to re-use the
existing DOM structure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> oldRootElement, oldRootContainer;</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Once we’ve got an element and a root DOM node to mount it
in we can finally render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> renderElement = <span class="hljs-function">(<span class="hljs-params">element, root, index</span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>During client transitions we create our root
elements as we go.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!root &amp;&amp; <span class="hljs-keyword">this</span>._previouslyRendered) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>If the <em>previous</em> render had elements that
we can re-use we’ll render into them.</p>
<p>DOM re-use is currently opt-in.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reuseDom) {
					oldRootElement = <span class="hljs-built_in">document</span>.querySelector(
						<span class="hljs-string">`div[<span class="hljs-subst">${REACT_SERVER_DATA_ATTRIBUTE}</span>="<span class="hljs-subst">${index}</span>"]`</span>
					);
					oldRootContainer = <span class="hljs-built_in">document</span>.querySelector(
						<span class="hljs-string">`div[<span class="hljs-subst">${PAGE_CONTAINER_NODE_ID}</span>="<span class="hljs-subst">${index}</span>"]`</span>
					);
				}</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>The current strategy for re-use is: So long
as the <em>shape</em> of the root structure is the
same, we’ll re-use.  Once the new page’s
shape diverges, we’ll blow away the
remaining elements left over from the
previous page and create everything for the
new page as we go.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reuseDom &amp;&amp; element.containerOpen &amp;&amp; oldRootContainer) {
					mountNode = oldRootContainer;
					<span class="hljs-keyword">this</span>._updateContainerNodeAttributes(
						mountNode,
						element.containerOpen
					);
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reuseDom &amp;&amp; element.containerClose &amp;&amp; !oldRootContainer &amp;&amp; !oldRootElement) {
					mountNode = mountNode.parentNode;
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reuseDom &amp;&amp; oldRootElement) {
					root = oldRootElement;
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">this</span>._cleanupPreviousRender(index);
					<span class="hljs-keyword">if</span> (element.containerOpen){</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>If we’re opening a container that’s
our new mountNode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						mountNode = <span class="hljs-keyword">this</span>._createContainerNode(
							mountNode,
							element.containerOpen,
							index
						);
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.containerClose) {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>If we’re closing a container its
parent is once again our mountNode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						mountNode = mountNode.parentNode;
					} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!element.isTheFold) {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Need a new root element in our
current mountNode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						root = <span class="hljs-keyword">this</span>._createReactServerRootNode(mountNode, index)
					}
				}

			}

			<span class="hljs-keyword">if</span> (element.containerOpen || element.containerClose){
				<span class="hljs-keyword">return</span>; <span class="hljs-comment">// Nothing left to do.</span>
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.isTheFold) {
				<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._previouslyRendered){
					logTimingData(<span class="hljs-string">`renderAboveTheFold.fromStart`</span>, tStart);
					logTimingData(<span class="hljs-string">`renderAboveTheFold.individual`</span>, <span class="hljs-number">0</span>, totalRenderTime);
					logTimingData(<span class="hljs-string">`renderAboveTheFold.elementCount`</span>, <span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);

					performanceMark(<span class="hljs-string">'renderAboveTheFold'</span>);
				}
				<span class="hljs-keyword">return</span>; <span class="hljs-comment">// Again, this isn't a real root element.</span>
			}

			<span class="hljs-keyword">var</span> name  = PageUtil.getElementDisplayName(element)
				,   timer = logger.timer(<span class="hljs-string">`renderElement.individual.<span class="hljs-subst">${name}</span>`</span>)

			element = React.cloneElement(element, { <span class="hljs-attr">context</span>: <span class="hljs-keyword">this</span>.context });
			<span class="hljs-keyword">var</span> renderFunc = ReactDOM.hydrate || ReactDOM.render;
			renderFunc(element, root);

			_.forEach(
				getRootElementAttributes(element),
				(v, k) =&gt; root.setAttribute(k, v)
			);

			totalRenderTime += timer.stop();

			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._previouslyRendered){
				<span class="hljs-keyword">var</span> tDisplay = root.getAttribute(<span class="hljs-string">'data-react-server-timing-offset'</span>);
				logTimingData(<span class="hljs-string">`displayElement.fromStart.<span class="hljs-subst">${name}</span>`</span>, <span class="hljs-number">0</span>, +tDisplay);
				logTimingData(<span class="hljs-string">`renderElement.fromStart.<span class="hljs-subst">${name}</span>`</span>, tStart);
			}
		};

		<span class="hljs-keyword">const</span> renderOne = <span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> promise.then(
			<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> rootNodePromises[index]
				.then(<span class="hljs-function"><span class="hljs-params">root</span> =&gt;</span> renderElement(element, root, index))
				.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>The only case where this should evaluate to false is
when <code>element</code> is a containerClose/containerOpen object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">const</span> componentType = <span class="hljs-keyword">typeof</span> element.type === <span class="hljs-string">'function'</span>
						? element.props.children.type.name
						: <span class="hljs-string">'element'</span>;
					logger.error(<span class="hljs-string">`Error with element <span class="hljs-subst">${componentType}</span>'s lifecycle methods at index <span class="hljs-subst">${index}</span>`</span>, e);
				})
		).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> logger.error(<span class="hljs-string">`Error with element promise <span class="hljs-subst">${index}</span>`</span>, e))

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._previouslyRendered){</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>On client transitions the root structure is laid out using a
state machine that requires us to render in order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			elementPromisesOr.reduce(
				<span class="hljs-function">(<span class="hljs-params">chain, promise, index</span>) =&gt;</span> chain.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> renderOne(promise, index)),
				Q()
			).then(retval.resolve);
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>On the first render we can go out of order because the server
has already laid out the root structure for us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			Q.all(elementPromisesOr.map(renderOne)).then(retval.resolve);</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Look out for a failsafe timeout from the server on our
first render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._failDfd.promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
				elementPromises.forEach(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Reject any elements that have failed to render</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					<span class="hljs-keyword">if</span> (promise.isPending()) {
						timeoutDfd[index].reject(<span class="hljs-string">`Error with element <span class="hljs-subst">${index}</span>, it failed to render within timeout time`</span>);
					}
				});
			});
		}

		<span class="hljs-keyword">return</span> retval.promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._reuseDom) {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Clean up any dangling nodes if the previous page had more
than we do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">this</span>._cleanupPreviousRender(elementPromises.length);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>This first one is just for historical continuity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			logTimingData(<span class="hljs-string">'render'</span>, t0);</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>These are more interesting.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			logTimingData(<span class="hljs-string">'renderCPUTime'</span>, <span class="hljs-number">0</span>, totalRenderTime);</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Don’t track this on client transitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._previouslyRendered){
				logTimingData(<span class="hljs-string">'renderFromStart'</span>, tStart);

				performanceMark(<span class="hljs-string">'renderComplete'</span>);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Some things are just different on our first pass.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">this</span>._previouslyRendered = <span class="hljs-literal">true</span>;

			<span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'render'</span>);
		});
	}

	<span class="hljs-comment">/**
	 * Cleans up a previous React render in the document. Unmounts all the components and destoys the mounting
	 * DOM node(s) that were created.
	 */</span>
	_cleanupPreviousRender(index) {

		index = index || <span class="hljs-number">0</span>; <span class="hljs-comment">// Default to everything.</span>

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._previouslyRendered &amp;&amp; !RLS().haveCleanedPreviousRender) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Only need to do this once per request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			RLS().haveCleanedPreviousRender = <span class="hljs-literal">true</span>;

			logger.debug(<span class="hljs-string">"Removing previous page's React components"</span>);

			[].slice.call(
				<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">`div[<span class="hljs-subst">${REACT_SERVER_DATA_ATTRIBUTE}</span>]`</span>)
			).forEach(<span class="hljs-function">(<span class="hljs-params">root, i</span>) =&gt;</span> {
				<span class="hljs-keyword">if</span> (i &gt;= index) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Since this node has a “data-react-server-root-id”
attribute, we can assume that we created it
and should destroy it. Destruction means
first unmounting from React and then
destroying the DOM node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					ReactDOM.unmountComponentAtNode(root);
					root.parentNode.removeChild(root);
				}
			});

			[].slice.call(
				<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">`div[<span class="hljs-subst">${PAGE_CONTAINER_NODE_ID}</span>]`</span>)
			).forEach(<span class="hljs-function">(<span class="hljs-params">root, i</span>) =&gt;</span> {
				<span class="hljs-keyword">if</span> (i &gt;= index) {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Gotta get rid of our containers,
too.  Need to do this <em>after</em>
killing the elements, since they
might live within these containers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>					root.parentNode.removeChild(root);
				}
			});
		}
	}

	<span class="hljs-comment">/**
	 * This method creates a new div to render a ReactElement in to at the end of the mount node.
	 */</span>
	_createReactServerRootNode(mountNode, index) {
		<span class="hljs-keyword">var</span> root = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);
		root.setAttribute(REACT_SERVER_DATA_ATTRIBUTE, index);
		mountNode.appendChild(root);
		<span class="hljs-keyword">return</span> root;
	}

	_createContainerNode(mountNode, attrs, i) {
		<span class="hljs-keyword">var</span> node = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);
		node.setAttribute(PAGE_CONTAINER_NODE_ID, i);
		_.forEach(attrs, (v, k) =&gt; node.setAttribute(k, v));
		mountNode.appendChild(node);
		<span class="hljs-keyword">return</span> node;
	}

	_updateContainerNodeAttributes(node, attrs) {
		_.forEach(attrs, (v, k) =&gt; node.setAttribute(k, v));
	}

	init () {

		<span class="hljs-keyword">var</span> unloadHandler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">this</span>.terminate(); };

		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span> &amp;&amp; <span class="hljs-built_in">window</span>.addEventListener) {
			<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"unload"</span>, unloadHandler);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span> &amp;&amp; <span class="hljs-built_in">window</span>.attachEvent) {
			<span class="hljs-built_in">window</span>.attachEvent(<span class="hljs-string">"onunload"</span>, unloadHandler);
		}

		<span class="hljs-keyword">this</span>._initializeHistoryListener(<span class="hljs-keyword">this</span>.context);</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>If this is a <em>refresh</em> there may be some request options
stashed in the history navigation stack frame we’re sitting
on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">const</span> state = <span class="hljs-keyword">this</span>._history.canClientNavigate() &amp;&amp; history.state;

		<span class="hljs-keyword">this</span>._navigateWithHistoryState({
			state,
			<span class="hljs-attr">path</span>: getHistoryPathname(),
			<span class="hljs-attr">type</span>: History.events.PAGELOAD,
		});
	}

	_navigateWithHistoryState({path, state, type, check}) {
		<span class="hljs-keyword">const</span> opts = (state||{}).reactServerFrame;

		<span class="hljs-keyword">if</span> (check &amp;&amp; !opts) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Not our frame.</span>

		<span class="hljs-keyword">this</span>.context.navigate(<span class="hljs-keyword">new</span> ClientRequest(path, opts||{}), type);
	}

	<span class="hljs-comment">/**
	 * Initializes us to listen to back button events. When the user presses the back button, the history
	 * listener will be called and cause a navigate() event.
	 */</span>
	_initializeHistoryListener() {

		<span class="hljs-keyword">this</span>._historyListener = <span class="hljs-function">(<span class="hljs-params">{state}</span>) =&gt;</span> {
			<span class="hljs-keyword">this</span>._navigateWithHistoryState({
				state,
				<span class="hljs-attr">path</span>  : <span class="hljs-keyword">this</span>._history.getPath(),
				<span class="hljs-attr">type</span>  : History.events.POPSTATE, <span class="hljs-comment">// Forward/back.</span>
				check : <span class="hljs-literal">true</span>, <span class="hljs-comment">// Only navigate if frame is ours.</span>
			});
		};

		<span class="hljs-keyword">this</span>._history = <span class="hljs-keyword">new</span> History();
		<span class="hljs-keyword">var</span> init = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>._history.on(<span class="hljs-keyword">this</span>._historyListener);</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Need to go <em>after</em> ‘load’ callbacks complete.
Safari fires a ‘popstate’ on load (RED-67600).
<a href="https://developer.mozilla.org/en-US/docs/Web/Events/popstate">https://developer.mozilla.org/en-US/docs/Web/Events/popstate</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.readyState === <span class="hljs-string">'complete'</span>){
			init();
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, ()=&gt;setTimeout(init,<span class="hljs-number">0</span>));
		}
	}

	_setupArrivalHandlers () {</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>used by <script> callbacks to register data sent down on the
initial connection after initial render</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-built_in">window</span>.__reactServerClientController = <span class="hljs-keyword">this</span>;
	}

	_ensureRootNodeDfd (index) {
		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._rootNodeDfds[index]){
			<span class="hljs-keyword">this</span>._rootNodeDfds[index] = Q.defer();
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._rootNodeDfds[index];
	}

	dataArrival (url, dehydratedEntry) {
		ReactServerAgent.cache().lateArrival(url, dehydratedEntry);
	}

	nodeArrival (startIndex, endIndex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>The server has just let us know that a pre-rendered root
element has arrived.  We’ll grab a reference to its DOM
node and un-block client-side rendering of the element that
we’re going to mount into it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = startIndex; i &lt;= endIndex; i++) {
			<span class="hljs-keyword">this</span>._ensureRootNodeDfd(i).resolve(
				<span class="hljs-keyword">this</span>.mountNode.querySelector(
					<span class="hljs-string">`div[<span class="hljs-subst">${REACT_SERVER_DATA_ATTRIBUTE}</span>="<span class="hljs-subst">${i}</span>"]`</span>
				)
			);
		}
	}

	failArrival () {
		<span class="hljs-keyword">this</span>._failDfd.resolve();
	}

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkNotEmpty</span>(<span class="hljs-params">state, key</span>) </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> state[key] === <span class="hljs-string">'undefined'</span>) {
		<span class="hljs-keyword">var</span> msg = key + <span class="hljs-string">' not defined in dehydrated state'</span>;
		logger.error(msg)
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
	}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildConfig</span>(<span class="hljs-params">dehydratedConfig</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>rehydrate the config object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./config"</span>)();
	config.rehydrate(dehydratedConfig);
	<span class="hljs-keyword">return</span> config;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildContext</span>(<span class="hljs-params">routes</span>) </span>{
	<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> RequestContext.Builder()
		.setRoutes(routes)
		.create();

	<span class="hljs-keyword">return</span> context;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Create a “user timing” in WebPageTest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">performanceMark</span>(<span class="hljs-params">name</span>) </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.performance &amp;&amp; performance.mark) {
		performance.mark(<span class="hljs-string">`react-server.<span class="hljs-subst">${name}</span>`</span>);
	}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logTimingData</span>(<span class="hljs-params">bucket, start, end = new Date</span>) </span>{
	<span class="hljs-keyword">if</span> (start === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>don’t send timing data if start timing is undefined</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span>;
	}

	logger.time(bucket, end - start);
}

<span class="hljs-built_in">module</span>.exports = ClientController;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
